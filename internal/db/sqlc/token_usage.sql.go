// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: token_usage.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllBotsTokenDailySeries = `-- name: GetAllBotsTokenDailySeries :many
SELECT
  bot_id,
  date_trunc('day', created_at)::date AS day,
  COALESCE(SUM(total_tokens), 0)::bigint AS total_tokens
FROM token_usage
WHERE created_at >= $1
  AND created_at < $2
GROUP BY bot_id, date_trunc('day', created_at)
ORDER BY day
`

type GetAllBotsTokenDailySeriesParams struct {
	Since pgtype.Timestamptz `json:"since"`
	Until pgtype.Timestamptz `json:"until"`
}

type GetAllBotsTokenDailySeriesRow struct {
	BotID       pgtype.UUID `json:"bot_id"`
	Day         pgtype.Date `json:"day"`
	TotalTokens int64       `json:"total_tokens"`
}

func (q *Queries) GetAllBotsTokenDailySeries(ctx context.Context, arg GetAllBotsTokenDailySeriesParams) ([]GetAllBotsTokenDailySeriesRow, error) {
	rows, err := q.db.Query(ctx, getAllBotsTokenDailySeries, arg.Since, arg.Until)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllBotsTokenDailySeriesRow
	for rows.Next() {
		var i GetAllBotsTokenDailySeriesRow
		if err := rows.Scan(&i.BotID, &i.Day, &i.TotalTokens); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllBotsTokenTotals = `-- name: GetAllBotsTokenTotals :many
SELECT
  bot_id,
  COALESCE(SUM(prompt_tokens), 0)::bigint AS prompt_tokens,
  COALESCE(SUM(completion_tokens), 0)::bigint AS completion_tokens,
  COALESCE(SUM(total_tokens), 0)::bigint AS total_tokens
FROM token_usage
GROUP BY bot_id
`

type GetAllBotsTokenTotalsRow struct {
	BotID            pgtype.UUID `json:"bot_id"`
	PromptTokens     int64       `json:"prompt_tokens"`
	CompletionTokens int64       `json:"completion_tokens"`
	TotalTokens      int64       `json:"total_tokens"`
}

func (q *Queries) GetAllBotsTokenTotals(ctx context.Context) ([]GetAllBotsTokenTotalsRow, error) {
	rows, err := q.db.Query(ctx, getAllBotsTokenTotals)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllBotsTokenTotalsRow
	for rows.Next() {
		var i GetAllBotsTokenTotalsRow
		if err := rows.Scan(
			&i.BotID,
			&i.PromptTokens,
			&i.CompletionTokens,
			&i.TotalTokens,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBotTokenDailySeries = `-- name: GetBotTokenDailySeries :many
SELECT
  date_trunc('day', created_at)::date AS day,
  COALESCE(SUM(total_tokens), 0)::bigint AS total_tokens,
  COALESCE(SUM(prompt_tokens), 0)::bigint AS prompt_tokens,
  COALESCE(SUM(completion_tokens), 0)::bigint AS completion_tokens
FROM token_usage
WHERE bot_id = $1
  AND created_at >= $2
  AND created_at < $3
GROUP BY date_trunc('day', created_at)
ORDER BY day
`

type GetBotTokenDailySeriesParams struct {
	BotID pgtype.UUID        `json:"bot_id"`
	Since pgtype.Timestamptz `json:"since"`
	Until pgtype.Timestamptz `json:"until"`
}

type GetBotTokenDailySeriesRow struct {
	Day              pgtype.Date `json:"day"`
	TotalTokens      int64       `json:"total_tokens"`
	PromptTokens     int64       `json:"prompt_tokens"`
	CompletionTokens int64       `json:"completion_tokens"`
}

func (q *Queries) GetBotTokenDailySeries(ctx context.Context, arg GetBotTokenDailySeriesParams) ([]GetBotTokenDailySeriesRow, error) {
	rows, err := q.db.Query(ctx, getBotTokenDailySeries, arg.BotID, arg.Since, arg.Until)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBotTokenDailySeriesRow
	for rows.Next() {
		var i GetBotTokenDailySeriesRow
		if err := rows.Scan(
			&i.Day,
			&i.TotalTokens,
			&i.PromptTokens,
			&i.CompletionTokens,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBotTokenTotal = `-- name: GetBotTokenTotal :one
SELECT
  COALESCE(SUM(prompt_tokens), 0)::bigint AS prompt_tokens,
  COALESCE(SUM(completion_tokens), 0)::bigint AS completion_tokens,
  COALESCE(SUM(total_tokens), 0)::bigint AS total_tokens
FROM token_usage
WHERE bot_id = $1
`

type GetBotTokenTotalRow struct {
	PromptTokens     int64 `json:"prompt_tokens"`
	CompletionTokens int64 `json:"completion_tokens"`
	TotalTokens      int64 `json:"total_tokens"`
}

func (q *Queries) GetBotTokenTotal(ctx context.Context, botID pgtype.UUID) (GetBotTokenTotalRow, error) {
	row := q.db.QueryRow(ctx, getBotTokenTotal, botID)
	var i GetBotTokenTotalRow
	err := row.Scan(&i.PromptTokens, &i.CompletionTokens, &i.TotalTokens)
	return i, err
}

const recordTokenUsage = `-- name: RecordTokenUsage :one
INSERT INTO token_usage (bot_id, prompt_tokens, completion_tokens, total_tokens, model, source)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, bot_id, prompt_tokens, completion_tokens, total_tokens, model, source, created_at
`

type RecordTokenUsageParams struct {
	BotID            pgtype.UUID `json:"bot_id"`
	PromptTokens     int32       `json:"prompt_tokens"`
	CompletionTokens int32       `json:"completion_tokens"`
	TotalTokens      int32       `json:"total_tokens"`
	Model            string      `json:"model"`
	Source           string      `json:"source"`
}

func (q *Queries) RecordTokenUsage(ctx context.Context, arg RecordTokenUsageParams) (TokenUsage, error) {
	row := q.db.QueryRow(ctx, recordTokenUsage,
		arg.BotID,
		arg.PromptTokens,
		arg.CompletionTokens,
		arg.TotalTokens,
		arg.Model,
		arg.Source,
	)
	var i TokenUsage
	err := row.Scan(
		&i.ID,
		&i.BotID,
		&i.PromptTokens,
		&i.CompletionTokens,
		&i.TotalTokens,
		&i.Model,
		&i.Source,
		&i.CreatedAt,
	)
	return i, err
}
