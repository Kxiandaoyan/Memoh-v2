// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: process_logs.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProcessLog = `-- name: CreateProcessLog :one
INSERT INTO process_logs (
    bot_id,
    chat_id,
    trace_id,
    user_id,
    channel,
    step,
    level,
    message,
    data,
    duration_ms
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, bot_id, chat_id, trace_id, user_id, channel, step, level, message, data, duration_ms, created_at
`

type CreateProcessLogParams struct {
	BotID      pgtype.UUID `json:"bot_id"`
	ChatID     pgtype.UUID `json:"chat_id"`
	TraceID    pgtype.UUID `json:"trace_id"`
	UserID     pgtype.Text `json:"user_id"`
	Channel    pgtype.Text `json:"channel"`
	Step       interface{} `json:"step"`
	Level      interface{} `json:"level"`
	Message    pgtype.Text `json:"message"`
	Data       []byte      `json:"data"`
	DurationMs pgtype.Int4 `json:"duration_ms"`
}

func (q *Queries) CreateProcessLog(ctx context.Context, arg CreateProcessLogParams) (ProcessLog, error) {
	row := q.db.QueryRow(ctx, createProcessLog,
		arg.BotID,
		arg.ChatID,
		arg.TraceID,
		arg.UserID,
		arg.Channel,
		arg.Step,
		arg.Level,
		arg.Message,
		arg.Data,
		arg.DurationMs,
	)
	var i ProcessLog
	err := row.Scan(
		&i.ID,
		&i.BotID,
		&i.ChatID,
		&i.TraceID,
		&i.UserID,
		&i.Channel,
		&i.Step,
		&i.Level,
		&i.Message,
		&i.Data,
		&i.DurationMs,
		&i.CreatedAt,
	)
	return i, err
}

const deleteProcessLogsOlderThan = `-- name: DeleteProcessLogsOlderThan :exec
DELETE FROM process_logs
WHERE created_at < $1
`

func (q *Queries) DeleteProcessLogsOlderThan(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteProcessLogsOlderThan, createdAt)
	return err
}

const getProcessLogStats = `-- name: GetProcessLogStats :many
SELECT
    step,
    COUNT(*) as count,
    AVG(duration_ms) as avg_duration_ms
FROM process_logs
WHERE bot_id = $1
AND created_at >= NOW() - INTERVAL '1 hour'
GROUP BY step
ORDER BY count DESC
`

type GetProcessLogStatsRow struct {
	Step          interface{} `json:"step"`
	Count         int64       `json:"count"`
	AvgDurationMs float64     `json:"avg_duration_ms"`
}

func (q *Queries) GetProcessLogStats(ctx context.Context, botID pgtype.UUID) ([]GetProcessLogStatsRow, error) {
	rows, err := q.db.Query(ctx, getProcessLogStats, botID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProcessLogStatsRow
	for rows.Next() {
		var i GetProcessLogStatsRow
		if err := rows.Scan(&i.Step, &i.Count, &i.AvgDurationMs); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessLogsByChat = `-- name: GetProcessLogsByChat :many
SELECT id, bot_id, chat_id, trace_id, user_id, channel, step, level, message, data, duration_ms, created_at FROM process_logs
WHERE bot_id = $1 AND chat_id = $2
ORDER BY created_at DESC
LIMIT $3
`

type GetProcessLogsByChatParams struct {
	BotID  pgtype.UUID `json:"bot_id"`
	ChatID pgtype.UUID `json:"chat_id"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) GetProcessLogsByChat(ctx context.Context, arg GetProcessLogsByChatParams) ([]ProcessLog, error) {
	rows, err := q.db.Query(ctx, getProcessLogsByChat, arg.BotID, arg.ChatID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProcessLog
	for rows.Next() {
		var i ProcessLog
		if err := rows.Scan(
			&i.ID,
			&i.BotID,
			&i.ChatID,
			&i.TraceID,
			&i.UserID,
			&i.Channel,
			&i.Step,
			&i.Level,
			&i.Message,
			&i.Data,
			&i.DurationMs,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessLogsByChatASC = `-- name: GetProcessLogsByChatASC :many
SELECT id, bot_id, chat_id, trace_id, user_id, channel, step, level, message, data, duration_ms, created_at FROM process_logs
WHERE bot_id = $1 AND chat_id = $2
ORDER BY created_at ASC
`

type GetProcessLogsByChatASCParams struct {
	BotID  pgtype.UUID `json:"bot_id"`
	ChatID pgtype.UUID `json:"chat_id"`
}

func (q *Queries) GetProcessLogsByChatASC(ctx context.Context, arg GetProcessLogsByChatASCParams) ([]ProcessLog, error) {
	rows, err := q.db.Query(ctx, getProcessLogsByChatASC, arg.BotID, arg.ChatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProcessLog
	for rows.Next() {
		var i ProcessLog
		if err := rows.Scan(
			&i.ID,
			&i.BotID,
			&i.ChatID,
			&i.TraceID,
			&i.UserID,
			&i.Channel,
			&i.Step,
			&i.Level,
			&i.Message,
			&i.Data,
			&i.DurationMs,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessLogsByStep = `-- name: GetProcessLogsByStep :many
SELECT id, bot_id, chat_id, trace_id, user_id, channel, step, level, message, data, duration_ms, created_at FROM process_logs
WHERE bot_id = $1 AND step = $2
ORDER BY created_at DESC
LIMIT $3
`

type GetProcessLogsByStepParams struct {
	BotID pgtype.UUID `json:"bot_id"`
	Step  interface{} `json:"step"`
	Limit int32       `json:"limit"`
}

func (q *Queries) GetProcessLogsByStep(ctx context.Context, arg GetProcessLogsByStepParams) ([]ProcessLog, error) {
	rows, err := q.db.Query(ctx, getProcessLogsByStep, arg.BotID, arg.Step, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProcessLog
	for rows.Next() {
		var i ProcessLog
		if err := rows.Scan(
			&i.ID,
			&i.BotID,
			&i.ChatID,
			&i.TraceID,
			&i.UserID,
			&i.Channel,
			&i.Step,
			&i.Level,
			&i.Message,
			&i.Data,
			&i.DurationMs,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessLogsByTimeRange = `-- name: GetProcessLogsByTimeRange :many
SELECT id, bot_id, chat_id, trace_id, user_id, channel, step, level, message, data, duration_ms, created_at FROM process_logs
WHERE bot_id = $1
AND created_at >= $2
AND created_at <= $3
ORDER BY created_at DESC
LIMIT $4
`

type GetProcessLogsByTimeRangeParams struct {
	BotID       pgtype.UUID        `json:"bot_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) GetProcessLogsByTimeRange(ctx context.Context, arg GetProcessLogsByTimeRangeParams) ([]ProcessLog, error) {
	rows, err := q.db.Query(ctx, getProcessLogsByTimeRange,
		arg.BotID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProcessLog
	for rows.Next() {
		var i ProcessLog
		if err := rows.Scan(
			&i.ID,
			&i.BotID,
			&i.ChatID,
			&i.TraceID,
			&i.UserID,
			&i.Channel,
			&i.Step,
			&i.Level,
			&i.Message,
			&i.Data,
			&i.DurationMs,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessLogsByTrace = `-- name: GetProcessLogsByTrace :many
SELECT id, bot_id, chat_id, trace_id, user_id, channel, step, level, message, data, duration_ms, created_at FROM process_logs
WHERE trace_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetProcessLogsByTrace(ctx context.Context, traceID pgtype.UUID) ([]ProcessLog, error) {
	rows, err := q.db.Query(ctx, getProcessLogsByTrace, traceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProcessLog
	for rows.Next() {
		var i ProcessLog
		if err := rows.Scan(
			&i.ID,
			&i.BotID,
			&i.ChatID,
			&i.TraceID,
			&i.UserID,
			&i.Channel,
			&i.Step,
			&i.Level,
			&i.Message,
			&i.Data,
			&i.DurationMs,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentProcessLogs = `-- name: GetRecentProcessLogs :many
SELECT id, bot_id, chat_id, trace_id, user_id, channel, step, level, message, data, duration_ms, created_at FROM process_logs
WHERE bot_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetRecentProcessLogsParams struct {
	BotID pgtype.UUID `json:"bot_id"`
	Limit int32       `json:"limit"`
}

func (q *Queries) GetRecentProcessLogs(ctx context.Context, arg GetRecentProcessLogsParams) ([]ProcessLog, error) {
	rows, err := q.db.Query(ctx, getRecentProcessLogs, arg.BotID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProcessLog
	for rows.Next() {
		var i ProcessLog
		if err := rows.Scan(
			&i.ID,
			&i.BotID,
			&i.ChatID,
			&i.TraceID,
			&i.UserID,
			&i.Channel,
			&i.Step,
			&i.Level,
			&i.Message,
			&i.Data,
			&i.DurationMs,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
