// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: bot_teams.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTeamMember = `-- name: AddTeamMember :one
INSERT INTO bot_team_members (team_id, source_bot_id, target_bot_id, role_description)
VALUES ($1, $2, $3, $4)
ON CONFLICT (team_id, source_bot_id, target_bot_id) DO UPDATE SET role_description = EXCLUDED.role_description
RETURNING id, team_id, source_bot_id, target_bot_id, role_description, created_at
`

type AddTeamMemberParams struct {
	TeamID          pgtype.UUID `json:"team_id"`
	SourceBotID     pgtype.UUID `json:"source_bot_id"`
	TargetBotID     pgtype.UUID `json:"target_bot_id"`
	RoleDescription string      `json:"role_description"`
}

func (q *Queries) AddTeamMember(ctx context.Context, arg AddTeamMemberParams) (BotTeamMember, error) {
	row := q.db.QueryRow(ctx, addTeamMember,
		arg.TeamID,
		arg.SourceBotID,
		arg.TargetBotID,
		arg.RoleDescription,
	)
	var i BotTeamMember
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.SourceBotID,
		&i.TargetBotID,
		&i.RoleDescription,
		&i.CreatedAt,
	)
	return i, err
}

const checkCallPermission = `-- name: CheckCallPermission :one
SELECT COUNT(*) AS cnt
FROM bot_team_members btm
WHERE btm.source_bot_id = $1 AND btm.target_bot_id = $2
`

type CheckCallPermissionParams struct {
	SourceBotID pgtype.UUID `json:"source_bot_id"`
	TargetBotID pgtype.UUID `json:"target_bot_id"`
}

func (q *Queries) CheckCallPermission(ctx context.Context, arg CheckCallPermissionParams) (int64, error) {
	row := q.db.QueryRow(ctx, checkCallPermission, arg.SourceBotID, arg.TargetBotID)
	var cnt int64
	err := row.Scan(&cnt)
	return cnt, err
}

const createBotCallLog = `-- name: CreateBotCallLog :one
INSERT INTO bot_call_logs (caller_bot_id, target_bot_id, message, status, call_depth)
VALUES ($1, $2, $3, 'pending', $4)
RETURNING id, caller_bot_id, target_bot_id, message, result, status, call_depth, created_at, completed_at
`

type CreateBotCallLogParams struct {
	CallerBotID pgtype.UUID `json:"caller_bot_id"`
	TargetBotID pgtype.UUID `json:"target_bot_id"`
	Message     string      `json:"message"`
	CallDepth   int32       `json:"call_depth"`
}

func (q *Queries) CreateBotCallLog(ctx context.Context, arg CreateBotCallLogParams) (BotCallLog, error) {
	row := q.db.QueryRow(ctx, createBotCallLog,
		arg.CallerBotID,
		arg.TargetBotID,
		arg.Message,
		arg.CallDepth,
	)
	var i BotCallLog
	err := row.Scan(
		&i.ID,
		&i.CallerBotID,
		&i.TargetBotID,
		&i.Message,
		&i.Result,
		&i.Status,
		&i.CallDepth,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO bot_teams (owner_user_id, name, manager_bot_id)
VALUES ($1, $2, $3)
RETURNING id, owner_user_id, name, manager_bot_id, created_at, updated_at
`

type CreateTeamParams struct {
	OwnerUserID  pgtype.UUID `json:"owner_user_id"`
	Name         string      `json:"name"`
	ManagerBotID pgtype.UUID `json:"manager_bot_id"`
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (BotTeam, error) {
	row := q.db.QueryRow(ctx, createTeam, arg.OwnerUserID, arg.Name, arg.ManagerBotID)
	var i BotTeam
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Name,
		&i.ManagerBotID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTeam = `-- name: DeleteTeam :exec
DELETE FROM bot_teams WHERE id = $1
`

func (q *Queries) DeleteTeam(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTeam, id)
	return err
}

const getTeamByID = `-- name: GetTeamByID :one
SELECT id, owner_user_id, name, manager_bot_id, created_at, updated_at FROM bot_teams WHERE id = $1
`

func (q *Queries) GetTeamByID(ctx context.Context, id pgtype.UUID) (BotTeam, error) {
	row := q.db.QueryRow(ctx, getTeamByID, id)
	var i BotTeam
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Name,
		&i.ManagerBotID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTeamByManagerBot = `-- name: GetTeamByManagerBot :one
SELECT id, owner_user_id, name, manager_bot_id, created_at, updated_at FROM bot_teams WHERE manager_bot_id = $1
`

func (q *Queries) GetTeamByManagerBot(ctx context.Context, managerBotID pgtype.UUID) (BotTeam, error) {
	row := q.db.QueryRow(ctx, getTeamByManagerBot, managerBotID)
	var i BotTeam
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Name,
		&i.ManagerBotID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllCallableTargetsForBot = `-- name: ListAllCallableTargetsForBot :many
SELECT DISTINCT btm.target_bot_id, btm.role_description,
       b.display_name AS target_display_name, b.metadata AS target_metadata,
       bt.id AS team_id, bt.name AS team_name
FROM bot_team_members btm
JOIN bots b ON b.id = btm.target_bot_id
JOIN bot_teams bt ON bt.id = btm.team_id
WHERE btm.source_bot_id = $1
`

type ListAllCallableTargetsForBotRow struct {
	TargetBotID       pgtype.UUID `json:"target_bot_id"`
	RoleDescription   string      `json:"role_description"`
	TargetDisplayName pgtype.Text `json:"target_display_name"`
	TargetMetadata    []byte      `json:"target_metadata"`
	TeamID            pgtype.UUID `json:"team_id"`
	TeamName          string      `json:"team_name"`
}

func (q *Queries) ListAllCallableTargetsForBot(ctx context.Context, sourceBotID pgtype.UUID) ([]ListAllCallableTargetsForBotRow, error) {
	rows, err := q.db.Query(ctx, listAllCallableTargetsForBot, sourceBotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllCallableTargetsForBotRow
	for rows.Next() {
		var i ListAllCallableTargetsForBotRow
		if err := rows.Scan(
			&i.TargetBotID,
			&i.RoleDescription,
			&i.TargetDisplayName,
			&i.TargetMetadata,
			&i.TeamID,
			&i.TeamName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllTeamContextForBot = `-- name: ListAllTeamContextForBot :many
SELECT bt.id AS team_id, bt.name AS team_name,
       bt.manager_bot_id,
       mb.display_name AS manager_display_name,
       btm.source_bot_id, btm.target_bot_id, btm.role_description,
       b.display_name AS target_display_name,
       b.metadata AS target_metadata
FROM bot_teams bt
JOIN bot_team_members btm ON btm.team_id = bt.id
JOIN bots b ON b.id = btm.target_bot_id
LEFT JOIN bots mb ON mb.id = bt.manager_bot_id
WHERE btm.source_bot_id = $1
ORDER BY bt.created_at ASC, btm.created_at ASC
`

type ListAllTeamContextForBotRow struct {
	TeamID             pgtype.UUID `json:"team_id"`
	TeamName           string      `json:"team_name"`
	ManagerBotID       pgtype.UUID `json:"manager_bot_id"`
	ManagerDisplayName pgtype.Text `json:"manager_display_name"`
	SourceBotID        pgtype.UUID `json:"source_bot_id"`
	TargetBotID        pgtype.UUID `json:"target_bot_id"`
	RoleDescription    string      `json:"role_description"`
	TargetDisplayName  pgtype.Text `json:"target_display_name"`
	TargetMetadata     []byte      `json:"target_metadata"`
}

func (q *Queries) ListAllTeamContextForBot(ctx context.Context, sourceBotID pgtype.UUID) ([]ListAllTeamContextForBotRow, error) {
	rows, err := q.db.Query(ctx, listAllTeamContextForBot, sourceBotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllTeamContextForBotRow
	for rows.Next() {
		var i ListAllTeamContextForBotRow
		if err := rows.Scan(
			&i.TeamID,
			&i.TeamName,
			&i.ManagerBotID,
			&i.ManagerDisplayName,
			&i.SourceBotID,
			&i.TargetBotID,
			&i.RoleDescription,
			&i.TargetDisplayName,
			&i.TargetMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBotCallLogs = `-- name: ListBotCallLogs :many
SELECT id, caller_bot_id, target_bot_id, message, result, status, call_depth, created_at, completed_at FROM bot_call_logs
WHERE caller_bot_id = $1 OR target_bot_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListBotCallLogsParams struct {
	CallerBotID pgtype.UUID `json:"caller_bot_id"`
	Limit       int32       `json:"limit"`
}

func (q *Queries) ListBotCallLogs(ctx context.Context, arg ListBotCallLogsParams) ([]BotCallLog, error) {
	rows, err := q.db.Query(ctx, listBotCallLogs, arg.CallerBotID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BotCallLog
	for rows.Next() {
		var i BotCallLog
		if err := rows.Scan(
			&i.ID,
			&i.CallerBotID,
			&i.TargetBotID,
			&i.Message,
			&i.Result,
			&i.Status,
			&i.CallDepth,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCallableTargets = `-- name: ListCallableTargets :many
SELECT btm.id, btm.target_bot_id, btm.role_description,
       b.display_name AS target_display_name, b.metadata AS target_metadata
FROM bot_team_members btm
JOIN bots b ON b.id = btm.target_bot_id
WHERE btm.team_id = $1 AND btm.source_bot_id = $2
`

type ListCallableTargetsParams struct {
	TeamID      pgtype.UUID `json:"team_id"`
	SourceBotID pgtype.UUID `json:"source_bot_id"`
}

type ListCallableTargetsRow struct {
	ID                pgtype.UUID `json:"id"`
	TargetBotID       pgtype.UUID `json:"target_bot_id"`
	RoleDescription   string      `json:"role_description"`
	TargetDisplayName pgtype.Text `json:"target_display_name"`
	TargetMetadata    []byte      `json:"target_metadata"`
}

func (q *Queries) ListCallableTargets(ctx context.Context, arg ListCallableTargetsParams) ([]ListCallableTargetsRow, error) {
	rows, err := q.db.Query(ctx, listCallableTargets, arg.TeamID, arg.SourceBotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCallableTargetsRow
	for rows.Next() {
		var i ListCallableTargetsRow
		if err := rows.Scan(
			&i.ID,
			&i.TargetBotID,
			&i.RoleDescription,
			&i.TargetDisplayName,
			&i.TargetMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamMembersByTeam = `-- name: ListTeamMembersByTeam :many
SELECT btm.id, btm.team_id, btm.source_bot_id, btm.target_bot_id, btm.role_description, btm.created_at,
       b.display_name AS target_display_name, b.metadata AS target_metadata
FROM bot_team_members btm
JOIN bots b ON b.id = btm.target_bot_id
WHERE btm.team_id = $1
ORDER BY btm.created_at ASC
`

type ListTeamMembersByTeamRow struct {
	ID                pgtype.UUID        `json:"id"`
	TeamID            pgtype.UUID        `json:"team_id"`
	SourceBotID       pgtype.UUID        `json:"source_bot_id"`
	TargetBotID       pgtype.UUID        `json:"target_bot_id"`
	RoleDescription   string             `json:"role_description"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	TargetDisplayName pgtype.Text        `json:"target_display_name"`
	TargetMetadata    []byte             `json:"target_metadata"`
}

func (q *Queries) ListTeamMembersByTeam(ctx context.Context, teamID pgtype.UUID) ([]ListTeamMembersByTeamRow, error) {
	rows, err := q.db.Query(ctx, listTeamMembersByTeam, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTeamMembersByTeamRow
	for rows.Next() {
		var i ListTeamMembersByTeamRow
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.SourceBotID,
			&i.TargetBotID,
			&i.RoleDescription,
			&i.CreatedAt,
			&i.TargetDisplayName,
			&i.TargetMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamsByOwner = `-- name: ListTeamsByOwner :many
SELECT id, owner_user_id, name, manager_bot_id, created_at, updated_at FROM bot_teams WHERE owner_user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListTeamsByOwner(ctx context.Context, ownerUserID pgtype.UUID) ([]BotTeam, error) {
	rows, err := q.db.Query(ctx, listTeamsByOwner, ownerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BotTeam
	for rows.Next() {
		var i BotTeam
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Name,
			&i.ManagerBotID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeTeamMember = `-- name: RemoveTeamMember :exec
DELETE FROM bot_team_members WHERE id = $1
`

func (q *Queries) RemoveTeamMember(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, removeTeamMember, id)
	return err
}

const updateBotCallLog = `-- name: UpdateBotCallLog :exec
UPDATE bot_call_logs
SET status = $2, result = $3, completed_at = now()
WHERE id = $1
`

type UpdateBotCallLogParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
	Result pgtype.Text `json:"result"`
}

func (q *Queries) UpdateBotCallLog(ctx context.Context, arg UpdateBotCallLogParams) error {
	_, err := q.db.Exec(ctx, updateBotCallLog, arg.ID, arg.Status, arg.Result)
	return err
}

const updateTeamManagerBot = `-- name: UpdateTeamManagerBot :exec
UPDATE bot_teams SET manager_bot_id = $2, updated_at = now() WHERE id = $1
`

type UpdateTeamManagerBotParams struct {
	ID           pgtype.UUID `json:"id"`
	ManagerBotID pgtype.UUID `json:"manager_bot_id"`
}

func (q *Queries) UpdateTeamManagerBot(ctx context.Context, arg UpdateTeamManagerBotParams) error {
	_, err := q.db.Exec(ctx, updateTeamManagerBot, arg.ID, arg.ManagerBotID)
	return err
}
