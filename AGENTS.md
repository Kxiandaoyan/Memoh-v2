# AGENTS.md

## Project Overview

Memoh is a single-user, structured long-memory, containerized AI agent system. Users create AI bots and chat with them via Telegram, Feishu (Lark), Web, or Local CLI. Every bot has an independent container and memory system, allowing it to edit files, execute commands, and evolve itself over time.

The product is designed as a personal AI assistant platform — lightweight compared to enterprise solutions, but more powerful in per-bot capability. It competes with tools like OpenClaw, aiming for deeper bot autonomy (self-evolution, independent container, memory engineering) rather than breadth of integrations.

## Architecture Overview

The system consists of three core services:

| Service | Tech Stack | Port | Description |
|---------|-----------|------|-------------|
| **Server** (Backend) | Go + Echo | 8080 | Main service: REST API, auth, database, container management |
| **Agent Gateway** | Bun + Elysia | 8081 | AI chat gateway: handles chat requests and tool execution |
| **Web** (Frontend) | Vue 3 + Vite | 8082 | Management UI: visual configuration for Bots, Models, Channels, etc. |

### Data Flow

```
User ──► Channel Adapter (Telegram/Feishu/Web/CLI)
              │
              ▼
         Go Server (8080)
         ├── Auth / identity resolution
         ├── Conversation routing
         ├── Memory retrieval (Qdrant + BM25)
         └── Payload assembly
              │
              ▼
       Agent Gateway (8081)
       ├── System prompt generation (IDENTITY + SOUL + TASK + TOOLS)
       ├── LLM inference (via provider API)
       ├── Tool execution (MCP built-in + external)
       └── Subagent dispatch
              │
              ▼
         Go Server (8080)
         ├── Response persistence
         ├── Memory extraction
         ├── Token usage recording
         └── Message event broadcast
```

### Infrastructure Dependencies

| Component | Purpose | Notes |
|-----------|---------|-------|
| **PostgreSQL** | Relational data storage | All bot, user, config, message data |
| **Qdrant** | Vector database for memory semantic search | Stores bot memory embeddings |
| **Containerd** | Container runtime | Provides isolated environments per bot. macOS requires Lima; Windows requires WSL2 or Docker Desktop |

## Tech Stack

### Backend (Go)
- **Framework**: Echo (HTTP)
- **Dependency Injection**: Uber FX
- **Database Driver**: pgx/v5
- **Code Generation**: sqlc (SQL → Go)
- **API Docs**: Swagger/OpenAPI (swaggo)
- **Containers**: containerd v2

### Agent Gateway (TypeScript)
- **Runtime**: Bun
- **Framework**: Elysia
- **AI SDK**: Vercel AI SDK (model abstraction, streaming, tool execution)

### Frontend (TypeScript)
- **Framework**: Vue 3 (Composition API)
- **Build Tool**: Vite
- **State Management**: Pinia + Pinia Colada
- **UI**: Tailwind CSS + custom component library (`@memoh/ui`) + Reka UI
- **Package Manager**: pnpm monorepo

### Tooling
- **Task Runner**: mise
- **Package Managers**: pnpm (frontend monorepo), Go modules (backend)

## Project Structure

```
Memoh/
├── cmd/                        # Go application entry points
│   ├── agent/                  #   Main backend server (main.go)
│   ├── mcp/                    #   MCP server binary
│   │   └── template/           #   Default bot template files (IDENTITY.md, SOUL.md, TOOLS.md, etc.)
│   └── cli/                    #   CLI tool
├── internal/                   # Go backend core code
│   ├── handlers/               #   HTTP handlers (REST API)
│   ├── bots/                   #   Bot management types & service
│   ├── templates/              #   Bot template system (13 predefined persona templates)
│   │   ├── templates.go        #     Template registry with go:embed
│   │   ├── handler.go          #     HTTP handler for GET /templates
│   │   └── <template-id>/      #     Per-template directories (identity.md, soul.md, task.md)
│   ├── db/                     #   Database layer
│   │   └── sqlc/               #   ⚠️ Auto-generated by sqlc — DO NOT modify manually
│   ├── channel/                #   Channel adapters (Telegram, Feishu, Local)
│   ├── memory/                 #   Memory / embedding system
│   ├── mcp/                    #   MCP protocol implementation & tool gateway
│   ├── conversation/           #   Conversation flow management & gateway communication
│   │   └── flow/               #     Chat/stream/heartbeat resolver (gateway HTTP client)
│   ├── heartbeat/              #   Heartbeat engine & self-evolution system
│   │   ├── engine.go           #     Periodic/event-driven trigger engine
│   │   ├── evolution_log.go    #     Evolution log service
│   │   └── types.go            #     Types, evolution reflection prompt
│   ├── containerd/             #   Container management (containerd v2)
│   ├── embeddings/             #   Embedding resolver (multi-provider)
│   ├── accounts/               #   User account management
│   ├── models/                 #   LLM model registry
│   ├── providers/              #   LLM provider management
│   ├── schedule/               #   Cron scheduled task management
│   ├── subagent/               #   Sub-agent definitions & context
│   ├── settings/               #   System settings
│   ├── policy/                 #   Access policy engine
│   ├── preauth/                #   Pre-authentication for guest access
│   ├── bind/                   #   Channel identity binding
│   ├── searchproviders/        #   Search engine provider management
│   ├── message/                #   Message persistence & event hub
│   ├── identity/               #   Identity validation utilities
│   ├── auth/                   #   JWT token generation & validation
│   ├── config/                 #   Configuration loading (config.toml)
│   ├── boot/                   #   Runtime configuration bootstrapping
│   ├── server/                 #   Echo server setup & handler registration
│   ├── logger/                 #   Structured logging (slog)
│   └── version/                #   Build version information
├── agent/                      # Agent Gateway (Bun/Elysia)
│   └── src/
│       ├── agent.ts            #   Core agent logic (system prompt, tool execution, streaming)
│       ├── model.ts            #   LLM model creation (Vercel AI SDK)
│       ├── modules/
│       │   └── chat.ts         #   Chat endpoints (/chat, /chat/stream, /chat/trigger-schedule)
│       ├── tools/              #   Tool implementations (file, exec, web, memory, schedule, etc.)
│       ├── prompts/            #   Prompt templates (system, schedule, subagent)
│       └── middlewares/        #   Auth middleware
├── packages/                   # Frontend monorepo
│   ├── web/                    #   Main web app (Vue 3)
│   │   └── src/
│   │       └── pages/          #   Page components
│   │           ├── bots/       #     Bot list, detail, create, settings, evolution, etc.
│   │           ├── chat/       #     Chat interface with streaming
│   │           ├── models/     #     Model & provider management
│   │           ├── settings/   #     System settings
│   │           └── ...         #     Schedules, token-usage, shared-workspace, etc.
│   ├── ui/                     #   Shared UI component library
│   ├── sdk/                    #   TypeScript SDK (auto-generated from OpenAPI)
│   ├── cli/                    #   TypeScript CLI
│   └── config/                 #   Shared configuration utilities
├── db/                         # Database
│   ├── migrations/             #   SQL migration files (0001–0016)
│   └── queries/                #   SQL query files (sqlc input)
├── docker/                     # Docker configuration & Dockerfiles
├── scripts/                    # Utility scripts
├── config.toml.example         # Configuration template
├── docker-compose.yml          # Docker Compose orchestration
├── mise.toml                   # mise tasks and tool version definitions
└── sqlc.yaml                   # sqlc code generation config
```

## Feature Inventory

Each subsystem is documented with: what it does, where the code lives, current status, and known gaps.

### Bot Management

| | |
|---|---|
| **What** | Full CRUD for bots, membership (owner/admin/member), lifecycle management (creating → ready → deleting), runtime health checks |
| **Code** | `internal/bots/`, `internal/handlers/users.go` |
| **Status** | Complete |

Bots are the core entity. Each bot has an owner, optional members, a container, memory, prompts (identity/soul/task), and channel configurations. The lifecycle transitions are: `creating` → `ready` → `deleting`. Runtime checks validate container health, data paths, and deletion state.

### Bot Templates

| | |
|---|---|
| **What** | 13 predefined persona templates (10 from Solo-Company-Skill thought-leader models + 3 productivity originals), selectable during bot creation |
| **Code** | `internal/templates/` (Go, 39 embedded Markdown files), `packages/web/src/pages/bots/components/create-bot.vue` |
| **Status** | Backend complete. Frontend 2-step creation flow implemented. SDK regeneration needed (`mise run swagger-generate && mise run sdk-generate`) |

Templates provide pre-built identity, soul, and task definitions. When a user creates a bot and selects a template, the backend applies the template's content to the bot's prompts via `UpdatePrompts`. The frontend presents a grid of template cards in step 1, then the standard bot configuration form in step 2.

**Available templates (10 Solo-Company ports):**

| ID | Mental Model | Category | Focus |
|----|-------------|----------|-------|
| `ceo-bezos` | Jeff Bezos | Business | Strategic decisions, business models, prioritization |
| `cto-vogels` | Werner Vogels | Development | Tech architecture, selection, reliability |
| `fullstack-dhh` | DHH | Development | Code implementation, tech approach, code review |
| `interaction-cooper` | Alan Cooper | Design | User flows, Persona-driven design, interaction patterns |
| `marketing-godin` | Seth Godin | Business | Positioning, differentiation, growth strategy |
| `operations-pg` | Paul Graham | Business | Cold start, user retention, community ops |
| `product-norman` | Don Norman | Design | Product definition, usability, cognitive design |
| `qa-bach` | James Bach | Development | Test strategy, risk assessment, quality control |
| `sales-ross` | Aaron Ross | Business | Pricing, sales funnels, conversion optimization |
| `ui-duarte` | Matías Duarte | Design | Visual design, design systems, typography & color |

**Original templates (3):**

| ID | Name | Category | Focus |
|----|------|----------|-------|
| `research-analyst` | 研究分析师 | Productivity | Deep research, multi-source verification, structured output |
| `daily-secretary` | 日程秘书 | Productivity | Task management, scheduling, commitment tracking |
| `knowledge-curator` | 知识管理师 | Productivity | Knowledge capture, organization, second brain |

Each template consists of three Markdown files stored in `internal/templates/<template-id>/`:
- **`identity.md`** — Role definition + persona (who, background, core philosophy)
- **`soul.md`** — Core beliefs, principles, communication style
- **`task.md`** — Decision frameworks, checklists, output format

Content is extracted from the Solo-Company-Skill project's single-file agents, split into our three-file format, written in Chinese, and condensed for maximum information density. Templates are compiled into the Go binary via `go:embed`. API endpoints: `GET /templates` (list all), `GET /templates/:id` (get one).

### Conversation & Chat

| | |
|---|---|
| **What** | Streaming and non-streaming chat, conversation routing, conversation summaries, SSE event broadcasting |
| **Code** | `internal/conversation/`, `internal/conversation/flow/`, `agent/src/modules/chat.ts`, `agent/src/agent.ts` |
| **Status** | Complete |

The Go server resolves a chat request into a full payload (model config, memory context, system files, MCP connections, skills) and forwards it to the Agent Gateway. The gateway generates the LLM response with tool execution. Responses are streamed back via SSE or returned as a single JSON response. Conversation summaries are generated by the gateway's `/chat/summarize` endpoint and stored for context compression.

### Memory System

| | |
|---|---|
| **What** | Hybrid memory: Qdrant vector semantic search + BM25 keyword indexing + LLM-based memory extraction and compaction |
| **Code** | `internal/memory/`, `internal/embeddings/` |
| **Status** | Complete |
| **Known Gap** | Embedding provider support is limited — only OpenAI-compatible and DashScope text embeddings are implemented. Other providers (Bedrock, etc.) return "provider not implemented" errors (`internal/embeddings/resolver.go:128,168`). |

Memory flow:
1. After each conversation round, the Go server extracts key facts from the exchange using an LLM
2. Extracted facts are embedded (vectorized) and stored in Qdrant
3. On subsequent conversations, relevant memories are retrieved via semantic search and BM25 keyword matching
4. Memory compaction (triggered manually or during maintenance) uses an LLM to merge similar entries and remove noise

The memory system supports per-bot isolation (each bot has its own Qdrant collection partition).

### Container System

| | |
|---|---|
| **What** | Per-bot isolated containerd containers with file management, command execution, snapshots, and task lifecycle |
| **Code** | `internal/containerd/`, `internal/handlers/containerd.go` |
| **Status** | Complete |
| **Known Gap** | macOS development requires running containerd via Lima (`mise run lima-up`). No native Windows containerd support; requires WSL2 or Docker Desktop. |

Each bot gets its own container instance based on a pre-built MCP image. The container provides:
- File I/O (read, write, list, edit files in the bot's data directory)
- Command execution (arbitrary shell commands inside the sandbox)
- Snapshots (point-in-time backups for rollback)
- Skill installation (via ClawHub CLI or manual file creation)
- Shared workspace mounting (`/shared` directory accessible by all bots)

Container lifecycle: create → start → stop → delete. Snapshots can be created at any time and restored later.

### Channel Adapters

| | |
|---|---|
| **What** | Multi-platform message routing: Telegram, Feishu (Lark), Web, Local CLI |
| **Code** | `internal/channel/`, `internal/channel/adapters/` |
| **Status** | 4 adapters implemented and working |
| **Known Gap** | Discord and Slack were mentioned in early documentation but are not implemented and are not currently planned. Telegram and Feishu binding error messages are vague ("binding is incomplete") — they should specify which configuration field is missing. |

Channel adapters handle inbound messages from different platforms, normalize them into a common format, route them to the appropriate bot, and deliver bot responses back. Each bot can have multiple channel configurations (e.g., one Telegram config and one Feishu config).

The Local CLI and Web adapters provide direct access without external platform setup, useful for development and testing.

### MCP Tool System

| | |
|---|---|
| **What** | 15 built-in tools + external MCP server connections (stdio and remote HTTP/SSE) + tool gateway + federation |
| **Code** | `internal/mcp/`, `agent/src/tools/`, `cmd/mcp/` |
| **Status** | Complete |

**Built-in tools** (always available to every bot):
- `read` / `write` / `list` / `edit` — File operations inside the container
- `exec` — Execute shell commands inside the container
- `send` — Send messages to channels or sessions
- `react` — Add/remove emoji reactions on messages
- `lookupChannelUser` — Look up users or groups by platform ID
- `searchMemory` — Search memories relevant to the current conversation
- `webSearch` — Search the web via configured search provider
- `listSchedule` / `getSchedule` / `createSchedule` / `updateSchedule` / `deleteSchedule` — Manage scheduled tasks

**External MCP servers** can be added per bot via the management UI. Two transport types are supported:
- **Stdio**: Runs inside the bot's container (e.g., `npx`, `node`, `python`)
- **Remote**: Connects to an external HTTP/SSE endpoint

The **tool gateway** proxies tool calls from the Agent Gateway to MCP servers running inside containers. **Federation** allows MCP tools from one context to be exposed in another.

### Heartbeat System

| | |
|---|---|
| **What** | Periodic timer-based and event-driven heartbeat triggers |
| **Code** | `internal/heartbeat/engine.go` |
| **Status** | Complete |

Heartbeats allow bots to act proactively without user interaction. Each heartbeat config specifies:
- **Interval** (in seconds) — how often the heartbeat fires
- **Prompt** — what the bot should do when triggered
- **Event triggers** — additional events that fire the heartbeat (`message_created`, `schedule_completed`)

New bots automatically receive a default heartbeat (hourly maintenance prompt). The evolution system uses a dedicated heartbeat with the `[evolution-reflection]` marker.

### Self-Evolution System

| | |
|---|---|
| **What** | Three-phase organic evolution cycle (Reflect → Experiment → Review) with evolution_logs tracking |
| **Code** | `internal/heartbeat/types.go` (prompt), `internal/heartbeat/evolution_log.go` (service), `internal/heartbeat/engine.go` (trigger integration), `internal/conversation/flow/resolver.go` (result capture), `cmd/mcp/template/SOUL.md` (philosophy), `packages/web/src/pages/bots/components/bot-evolution.vue` (frontend) |
| **Status** | Backend complete. Frontend evolution history timeline implemented. |
| **Known Gaps** | Evolution quality depends heavily on the underlying LLM's capability. There is no built-in rollback mechanism if a bad evolution degrades bot behavior — container snapshots serve as the manual workaround. Evolution log completion relies on parsing assistant text, which may miss edge cases. |

**Philosophy**: Evolution is organic — driven by real conversations, not forced schedules. If recent conversations went smoothly with no friction, no evolution is needed. The system only iterates when there is genuine material to learn from.

**Three-phase cycle** (defined in `EvolutionReflectionPrompt`):

1. **Phase 1: REFLECT** — Review conversation history for friction (wrong answers, frustrated user), delight (satisfied user), patterns (recurring topics), and gaps (missing knowledge). If nothing meaningful is found, the bot reports "no evolution needed" and stops.

2. **Phase 2: EXPERIMENT** — For each actionable insight, log it in `EXPERIMENTS.md` (trigger, observation, action, expected outcome) and apply a small, targeted change to the appropriate file (IDENTITY.md, SOUL.md, or TOOLS.md).

3. **Phase 3: REVIEW** — Self-healing maintenance: check scheduled tasks, distill daily notes into long-term memory, verify coordination files, and flag anomalies to the user.

**Evolution logging**: When an evolution heartbeat fires, the engine creates an `evolution_logs` record with status `running`. After the Agent Gateway returns the result, the resolver automatically completes the log with one of:
- `completed` — Changes were made
- `skipped` — No evolution needed
- `failed` — An error occurred

**API endpoints**:
- `GET /bots/:bot_id/evolution-logs` — List evolution history (paginated)
- `GET /bots/:bot_id/evolution-logs/:id` — Get a single log entry
- `POST /bots/:bot_id/evolution-logs/:id/complete` — Mark a log as completed (callback)

**Frontend**: The evolution page shows a status panel (enabled/disabled toggle, interval, manual trigger), an experiments timeline (parsed from EXPERIMENTS.md), an evolution history timeline (from evolution_logs with status badges, expandable agent response), and a persona file viewer.

### Subagents

| | |
|---|---|
| **What** | Definable sub-agents dispatched by the main agent during conversations, each with its own skills and system prompt |
| **Code** | `internal/subagent/`, `agent/src/tools/subagent.ts`, `agent/src/prompts/subagent.ts` |
| **Status** | Complete |

Subagents can be pre-registered via the management UI or auto-created by the agent at runtime. When dispatched, a subagent receives its own system prompt with specialized skills and context. The agent decides when to dispatch subagents based on the task at hand.

### Skills

| | |
|---|---|
| **What** | Container-stored skill files (Markdown) that extend bot capabilities, installable via ClawHub marketplace or manual creation |
| **Code** | `internal/handlers/containerd.go` (skill endpoints), `agent/src/agent.ts` (skill loading) |
| **Status** | Complete |

Skills are Markdown files stored in the bot's container. Each skill has a name, description, and content. The agent loads relevant skills based on the conversation context and applies their instructions. Skills can be installed from ClawHub (a community skill marketplace) or created manually via the UI.

### OpenViking Integration

| | |
|---|---|
| **What** | Tiered contextual memory database using a filesystem paradigm |
| **Code** | `internal/handlers/prompts.go` (config generation), `agent/src/agent.ts` (integration) |
| **Status** | Functional |
| **Known Gap** | The feature toggle exists in bot settings but lacks user-facing documentation explaining what OpenViking does, when to enable it, and how it differs from the standard memory system. Users may not understand the implications of enabling this feature. |

When enabled, OpenViking provides a structured filesystem-based context database for managing memories, resources, and skills with tiered context loading. An `ov.conf` file is auto-generated from the bot's current model settings.

### Schedule System

| | |
|---|---|
| **What** | Cron-based scheduled tasks that bots can create and manage |
| **Code** | `internal/schedule/`, `agent/src/tools/schedule.ts` |
| **Status** | Complete |

Bots can create, update, and delete scheduled tasks via conversation (using built-in schedule tools) or via the management API. Each schedule has a cron pattern, command prompt, optional max call limit, and enabled/disabled toggle. When a schedule fires, it triggers the bot through the same trigger-schedule pathway as heartbeats.

### Search Providers

| | |
|---|---|
| **What** | Pluggable web search backends (Brave, SerpAPI) |
| **Code** | `internal/searchproviders/` |
| **Status** | Complete |
| **Note** | Search providers are configured via the database (management UI), not via `config.toml`. Earlier documentation incorrectly referenced a `[brave]` config section. |

### Token Usage

| | |
|---|---|
| **What** | Per-bot daily and total token usage tracking with a cross-bot comparison dashboard |
| **Code** | `internal/handlers/token_usage.go`, `packages/web/src/pages/token-usage/` |
| **Status** | Complete |

Token usage is recorded after every LLM call (chat, heartbeat, schedule, memory operations). The frontend provides a dashboard with daily usage charts and bot-by-bot comparison.

### Shared Workspace

| | |
|---|---|
| **What** | Cross-bot shared file directory mounted at `/shared` in every container |
| **Code** | `internal/handlers/shared_files.go`, `packages/web/src/pages/shared-workspace/` |
| **Status** | Complete |

All bot containers mount the same host directory as `/shared`. Bots can use this for cross-agent coordination — one bot writes a file, another reads it. The management UI provides a file browser for viewing and editing shared files.

### Authentication & Users

| | |
|---|---|
| **What** | JWT authentication, admin/member roles, channel identity binding, password and profile management |
| **Code** | `internal/auth/`, `internal/accounts/`, `internal/bind/`, `internal/handlers/users.go` |
| **Status** | Complete |

Users authenticate via username/password and receive a JWT token. Channel identities (Telegram user, Feishu user, etc.) can be linked to user accounts via bind codes. The system supports admin and member roles, with admins having full access to all bots and settings.

## Objective Critique: Known Gaps and Limitations

An honest assessment of what is incomplete, rough, or needs improvement.

### Embedding Provider Support

Only OpenAI-compatible and DashScope text embeddings are implemented. Attempting to use other providers (e.g., Bedrock, Cohere) results in "provider not implemented" errors.

- Location: `internal/embeddings/resolver.go:128,168`
- Impact: Users with non-OpenAI embedding models cannot use the memory system
- Recommended fix: Implement a generic embedding provider adapter or fallback

### Channel Binding Error Messages

Telegram and Feishu adapters return vague "binding is incomplete" errors when required configuration fields are missing. The error messages do not specify which field is missing, making it difficult for users to diagnose configuration issues.

- Location: `internal/channel/adapters/telegram/config.go:68`, `internal/channel/adapters/feishu/config.go:68`
- Recommended fix: Return field-specific validation errors

### Channel Registry Startup Panic

The channel registry calls `panic(err)` if adapter registration fails during startup. This causes the entire server to crash rather than gracefully degrading with a warning.

- Location: `internal/channel/registry.go:47`
- Recommended fix: Return an error or log a warning and skip the failed adapter

### No Evolution Rollback Mechanism

The self-evolution system can modify IDENTITY.md, SOUL.md, and TOOLS.md but has no built-in way to undo a bad evolution. If an evolution cycle degrades bot behavior, the user must manually revert via container snapshots.

- Recommended fix: Add evolution diff tracking and a one-click rollback to the previous version

### OpenViking Documentation Gap

The OpenViking integration has a functional toggle in bot settings, but there is no user-facing documentation explaining:
- What OpenViking is and what it does
- When a user should enable vs. disable it
- How it interacts with the standard memory system
- What `ov.conf` parameters mean

### SDK Regeneration Required

After the recent template system and evolution log additions, the frontend TypeScript SDK is out of date. The following must be run to update it:

```bash
mise run swagger-generate && mise run sdk-generate
```

Until this is done, the `template_id` field in `CreateBotRequest` and the evolution log API functions are not available as typed SDK functions (the frontend currently uses `as any` casting and raw `client.get()` calls as workarounds).

### Configuration Inconsistencies

- **Default password**: `config.toml.example` uses `123456` as the default admin password, while `docker/config/config.docker.toml` and README use `admin123`. These should be aligned.
- **Search providers**: The `[brave]` configuration section previously documented in AGENTS.md does not exist in `config.toml`. Search providers are configured entirely via the database (management UI). This has been corrected in this document.

### Test Coverage

Some test files contain stub implementations that return "not implemented" errors (e.g., `internal/channel/inbound/identity_test.go:193`). Test coverage for the evolution system, template system, and memory compaction is not yet written.

### Platform Support

- **Windows**: No native containerd support. Development requires WSL2 or Docker Desktop with containerd backend.
- **macOS**: Requires Lima for containerd. Run `mise run lima-up` before development.
- **Linux**: Native containerd support; recommended for production deployment.

## Database Tables

| Table | Description |
|-------|-------------|
| `users` | User accounts (admin/member roles) |
| `channel_identities` | Unified identity system (cross-platform user linking) |
| `bots` | Bot definitions with model references, prompts, lifecycle status |
| `bot_members` | Bot membership (owner/admin/member per bot) |
| `bot_channel_configs` | Per-bot channel configurations (Telegram token, Feishu credentials, etc.) |
| `bot_channel_routes` | Conversation route mapping (which chat → which bot) |
| `bot_history_messages` | Unified message history across all channels |
| `llm_providers` | LLM provider configurations (API key, base URL) |
| `models` | Model definitions (chat/embedding types, dimensions, fallback) |
| `mcp_connections` | External MCP server configurations per bot |
| `containers` | Bot container instances (containerd metadata) |
| `snapshots` | Container snapshots for backup/restore |
| `schedule` | Cron-based scheduled tasks per bot |
| `subagents` | Sub-agent definitions (name, description, skills) |
| `search_providers` | Search engine provider configurations (Brave, SerpAPI) |
| `heartbeat_configs` | Per-bot heartbeat configurations (interval, prompt, event triggers) |
| `conversation_summaries` | LLM-generated conversation summaries for context compression |
| `token_usage` | Per-bot token consumption records (prompt/completion/total per call) |
| `evolution_logs` | Self-evolution execution history (status, changes, agent response) |

## Development Guide

### Prerequisites

1. Install [mise](https://mise.jdx.dev/)
2. Install toolchains and dependencies: `mise install`
3. Initialize the project: `mise run setup`
4. Copy the config file: `cp config.toml.example config.toml` and edit as needed
5. Start the dev environment: `mise run dev`

### Common Commands

| Command | Description |
|---------|-------------|
| `mise run dev` | Start the full dev environment (backend + agent gateway + frontend) |
| `mise run setup` | Initialize dev environment (sqlc gen + DB migration + dependency install) |
| `mise run sqlc-generate` | Regenerate Go code after modifying SQL files |
| `mise run swagger-generate` | Generate Swagger documentation |
| `mise run sdk-generate` | Generate TypeScript SDK (depends on swagger-generate) |
| `mise run db-up` | Initialize and migrate the database |
| `mise run db-down` | Drop the database |
| `mise run //agent:dev` | Start Agent Gateway only |
| `mise run //cmd/agent:start` | Start the backend server only |
| `mise run //packages/web:dev` | Start the frontend dev server only |

### Docker Deployment

```bash
docker compose up -d        # Start all services
# Visit http://localhost:8082
```

## Key Development Rules

### Database, sqlc & Migrations

1. **SQL queries** are defined in `db/queries/*.sql`.
2. All Go files under `internal/db/sqlc/` are auto-generated by sqlc. **DO NOT modify them manually.**
3. After modifying any SQL files (migrations or queries), run `mise run sqlc-generate` to update the generated Go code.

#### Migration Rules

Migrations live in `db/migrations/` and follow a dual-update convention:

- **`0001_init.up.sql` is the canonical full schema.** It always contains the complete, up-to-date database definition (all tables, indexes, constraints, etc.). When adding schema changes, you must **also update `0001_init.up.sql`** to reflect the final state.
- **Incremental migration files** (`0002_`, `0003_`, ...) contain only the diff needed to upgrade an existing database. They exist for environments that already have the schema and need to apply only the delta.
- **Both must be kept in sync**: every schema change requires updating `0001_init.up.sql` AND creating a new incremental migration file.
- **Naming**: `{NNNN}_{description}.up.sql` and `{NNNN}_{description}.down.sql`, where `{NNNN}` is a zero-padded sequential number (e.g., `0005`). Always use the next available number.
- **Paired files**: Every incremental migration **must** have both an `.up.sql` (apply) and a `.down.sql` (rollback) file.
- **Header comment**: Each file should start with a comment indicating the migration name and a brief description:
  ```sql
  -- 0005_add_feature_x
  -- Add feature_x column to bots table for ...
  ```
- **Idempotent DDL**: Use `IF NOT EXISTS` / `IF EXISTS` guards (e.g., `CREATE TABLE IF NOT EXISTS`, `ADD COLUMN IF NOT EXISTS`, `DROP TABLE IF EXISTS`) so migrations are safe to re-run.
- **Down migration must fully reverse up**: The `.down.sql` must cleanly undo everything its `.up.sql` does, in reverse order.
- **After creating or modifying migrations**, run `mise run sqlc-generate` to regenerate the Go code, then `mise run db-up` to apply.

### API Development Workflow

1. Write handlers in `internal/handlers/` with swaggo annotations.
2. Run `mise run swagger-generate` to update the OpenAPI docs.
3. Run `mise run sdk-generate` to update the frontend TypeScript SDK (`packages/sdk/`).
4. The frontend calls APIs via the auto-generated `@memoh/sdk`.

### Frontend Development

- Use Vue 3 Composition API with `<script setup>` style.
- Shared components belong in `packages/ui/`.
- API calls use the auto-generated `@memoh/sdk`.
- State management uses Pinia; data fetching uses Pinia Colada.

### Container Management

- macOS development requires running containerd via Lima (run `mise run lima-up`).
- In Docker deployment, containerd runs as a standalone service.
- Each bot has its own isolated container instance.

### Template Development

Templates live in `internal/templates/<template-id>/`. Each template directory contains three files:
- `identity.md` — Bot identity definition
- `soul.md` — Bot behavioral rules and communication style
- `task.md` — Bot task workflows and checklists

Template metadata (name, description, icon, category) is defined in `internal/templates/templates.go` in the `allMetas` slice. To add a new template:
1. Create a new directory under `internal/templates/` with the template ID as the directory name
2. Create `identity.md`, `soul.md`, and `task.md` in the directory
3. Add the metadata entry to `allMetas` in `templates.go`
4. The `go:embed` directive automatically picks up the new files

## Configuration

The main configuration file is `config.toml` (copied from `config.toml.example`), containing:

- `[log]` — Logging configuration (level, format)
- `[server]` — HTTP listen address
- `[admin]` — Admin account credentials (username, password, email)
- `[auth]` — JWT authentication settings (secret, expiration)
- `[containerd]` — Container runtime socket path and namespace
- `[mcp]` — MCP container image, snapshotter, data root, and mount configuration
- `[postgres]` — PostgreSQL connection (host, port, user, password, database, sslmode)
- `[qdrant]` — Qdrant vector database connection (base URL, API key, collection, timeout)
- `[agent_gateway]` — Agent Gateway address (host, port)
- `[web]` — Web frontend address (host, port)

Note: Search providers (Brave, SerpAPI) are configured via the management UI (database), not via `config.toml`.
